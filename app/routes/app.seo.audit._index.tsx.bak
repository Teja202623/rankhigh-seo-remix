// app/routes/app.seo.audit._index.tsx
/**
 * SEO Audit Results Page
 *
 * Displays the latest audit results with:
 * - Overall SEO score and statistics
 * - Issues grouped by severity
 * - Filtering by severity and issue type
 * - Search functionality
 * - Click-to-fix navigation
 * - Real-time audit status
 */

import { json, type LoaderFunctionArgs, type ActionFunctionArgs } from "@remix-run/node";
import { useLoaderData, useNavigate, useSubmit, useRevalidator } from "@remix-run/react";
import {
  Page,
  Layout,
  Card,
  Text,
  Button,
  ButtonGroup,
  Badge,
  IndexTable,
  EmptyState,
  Banner,
  Box,
  BlockStack,
  InlineStack,
  Select,
  TextField,
  ProgressBar,
  Icon,
} from "@shopify/polaris";
import {
  AlertCircleIcon,
  CheckCircleIcon,
  ClockIcon,
  SearchIcon,
} from "@shopify/polaris-icons";
import { authenticate } from "~/shopify.server";
import prisma from "~/db.server";
import { startAudit } from "~/services/audit/auditService.server";
import type { IssueSeverity, IssueType } from "~/types/audit";
import { useEffect, useState } from "react";
import { applyRateLimit, rateLimitExceeded } from "~/middleware/rateLimit.server";

// ====================
// LOADER
// ====================

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const { session } = await authenticate.admin(request);

  // Get or create store record
  const store = await prisma.store.upsert({
    where: { shopUrl: session.shop },
    create: {
      shopUrl: session.shop,
      accessToken: session.accessToken || "",
      plan: "FREE",
    },
    update: {
      accessToken: session.accessToken || "",
    },
  });

  // Get URL parameters for filtering
  const url = new URL(request.url);
  const severityFilter: string = url.searchParams.get("severity") || "all";
  const typeFilter: string = url.searchParams.get("type") || "all";
  const searchQuery: string = url.searchParams.get("search") || "";

  // Get latest audit
  const latestAudit = await prisma.audit.findFirst({
    where: { storeId: store.id },
    orderBy: { createdAt: "desc" },
  });

  // Check if can run new audit
  const auditPermission = await canRunAudit(store.id);

  // If no audit exists, return empty state
  if (!latestAudit) {
    return json({
      store,
      audit: null,
      issues: [],
      statistics: {
        totalIssues: 0,
        criticalIssues: 0,
        highIssues: 0,
        mediumIssues: 0,
        lowIssues: 0,
        overallScore: 0,
      },
      canRunAudit: auditPermission.allowed,
    auditRestriction: auditPermission.reason || null,
    nextAllowedTime: auditPermission.nextAllowedTime || null,
    filters: { severity: severityFilter, type: typeFilter, search: searchQuery },
    jobStatus: null,
  });
}

  // Get issues for the latest audit
  let issuesQuery: any = {
    where: {
      page: {
        storeId: store.id,
      },
      createdAt: {
        gte: latestAudit.createdAt,
      },
    },
    include: {
      page: true,
    },
    orderBy: [
      { severity: "asc" as const }, // CRITICAL first
      { createdAt: "desc" as const },
    ],
  };

  // Apply filters
  if (severityFilter !== "all") {
    issuesQuery.where.severity = severityFilter.toUpperCase();
  }

  if (typeFilter !== "all") {
    issuesQuery.where.type = typeFilter.toUpperCase();
  }

  if (searchQuery) {
    issuesQuery.where.OR = [
      { message: { contains: searchQuery, mode: "insensitive" as const } },
      { page: { title: { contains: searchQuery, mode: "insensitive" as const } } },
    ];
  }

  const issues = await prisma.sEOIssue.findMany(issuesQuery);

  issues.sort((a, b) => {
    const rank = { CRITICAL: 0, HIGH: 1, MEDIUM: 2, LOW: 3 } as Record<string, number>;
    const severityDiff = (rank[a.severity] ?? 4) - (rank[b.severity] ?? 4);
    if (severityDiff !== 0) return severityDiff;
    return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
  });

  // Calculate statistics
  const statistics = {
    totalIssues: latestAudit.criticalIssues + latestAudit.highIssues + latestAudit.mediumIssues + latestAudit.lowIssues,
    criticalIssues: latestAudit.criticalIssues,
    highIssues: latestAudit.highIssues,
    mediumIssues: latestAudit.mediumIssues,
    lowIssues: latestAudit.lowIssues,
    overallScore: latestAudit.overallScore || 0,
  };

  const jobStatus = await getAuditJobStatus(latestAudit.id);

  return json({
    store,
    audit: latestAudit,
    issues,
    statistics,
    canRunAudit: auditPermission.allowed,
    auditRestriction: auditPermission.reason || null,
    nextAllowedTime: auditPermission.nextAllowedTime || null,
    filters: { severity: severityFilter, type: typeFilter, search: searchQuery },
    jobStatus,
  });
};

// ====================
// ACTION
// ====================

export const action = async ({ request }: ActionFunctionArgs) => {
  const { session } = await authenticate.admin(request);

  const formData = await request.formData();
  const action = formData.get("action");

  if (action === "start_audit") {
    // Get store
    const store = await prisma.store.findUnique({
      where: { shopUrl: session.shop },
    });

    if (!store) {
      return json({ error: "Store not found" }, { status: 404 });
    }

    // Apply rate limiting for audits (10 per day for FREE tier)
    const rateLimitResult = await applyRateLimit(store.id, "AUDIT");
    if (!rateLimitResult.allowed) {
      return rateLimitExceeded(rateLimitResult.resetAt);
    }

    // Check if can run audit
    const permission = await canRunAudit(store.id);
    if (!permission.allowed) {
      return json({ error: permission.reason }, { status: 429 });
    }

    // Queue audit via BullMQ (falls back to sync if Redis unavailable)
    try {
      const auditId = await startAudit(store.id, session.shop);
      return json({ success: true, auditId });
    } catch (error) {
      console.error("Audit queueing failed:", error);
      return json({ error: "Audit failed to start" }, { status: 500 });
    }
  }

  return json({ error: "Invalid action" }, { status: 400 });
};

// ====================
// COMPONENT
// ====================

export default function AuditResultsPage() {
  const {
    store,
    audit,
    issues,
    statistics,
    canRunAudit,
    auditRestriction,
    nextAllowedTime,
    filters,
    jobStatus,
  } = useLoaderData<typeof loader>();

  const navigate = useNavigate();
  const submit = useSubmit();
  const revalidator = useRevalidator();
  const [isRunningAudit, setIsRunningAudit] = useState(false);

  useEffect(() => {
    if (
      jobStatus?.status === "waiting" ||
      jobStatus?.status === "active" ||
      audit?.status === "RUNNING"
    ) {
      const interval = setInterval(() => {
        revalidator.revalidate();
      }, 5000);
      return () => clearInterval(interval);
    }
  }, [jobStatus?.status, audit?.status, revalidator]);

  useEffect(() => {
    if (
      jobStatus?.status &&
      jobStatus.status !== "waiting" &&
      jobStatus.status !== "active"
    ) {
      setIsRunningAudit(false);
    }
  }, [jobStatus?.status]);

  // Handle filter changes
  const handleSeverityChange = (value: string) => {
    const params = new URLSearchParams();
    params.set("severity", value);
    if (filters.type !== "all") params.set("type", filters.type);
    if (filters.search) params.set("search", filters.search);
    navigate(`?${params.toString()}`);
  };

  const handleTypeChange = (value: string) => {
    const params = new URLSearchParams();
    if (filters.severity !== "all") params.set("severity", filters.severity);
    params.set("type", value);
    if (filters.search) params.set("search", filters.search);
    navigate(`?${params.toString()}`);
  };

  const handleSearchChange = (value: string) => {
    const params = new URLSearchParams();
    if (filters.severity !== "all") params.set("severity", filters.severity);
    if (filters.type !== "all") params.set("type", filters.type);
    if (value) params.set("search", value);
    navigate(`?${params.toString()}`);
  };

  const jobProgress =
    typeof jobStatus?.progress === "number"
      ? jobStatus.progress
      : typeof jobStatus?.progress === "object" && jobStatus?.progress
        ? (jobStatus.progress as { percentage?: number }).percentage ?? undefined
        : undefined;

  const jobStage =
    typeof jobStatus?.progress === "object" && jobStatus?.progress
      ? (jobStatus.progress as { stage?: string }).stage
      : undefined;

  // Handle start audit
  const handleStartAudit = () => {
    setIsRunningAudit(true);
    const formData = new FormData();
    formData.append("action", "start_audit");
    submit(formData, { method: "post" });
  };

  // Handle click to fix
  const handleFixIssue = (issue: any) => {
    // Determine the appropriate editor route based on issue type
    if (issue.type === "MISSING_META_TITLE" || issue.type === "DUPLICATE_META_TITLE" || issue.type === "MISSING_META_DESCRIPTION") {
      // Navigate to Meta Editor with resource pre-selected
      navigate(`/app/seo/meta?resource=${issue.page.shopifyId}&type=${issue.page.pageType}`);
    } else if (issue.type === "MISSING_ALT_TEXT") {
      // Navigate to Image ALT Manager with product pre-selected
      navigate(`/app/seo/images?product=${issue.page.shopifyId}`);
    }
    // Other issue types don't have direct fix actions yet
  };

  // Severity badge color mapping
  const getSeverityBadge = (severity: string) => {
    switch (severity) {
      case "CRITICAL":
        return <Badge tone="critical">Critical</Badge>;
      case "HIGH":
        return <Badge tone="warning">High</Badge>;
      case "MEDIUM":
        return <Badge tone="attention">Medium</Badge>;
      case "LOW":
        return <Badge tone="info">Low</Badge>;
      default:
        return <Badge>{severity}</Badge>;
    }
  };

  // Score color
  const getScoreColor = (score: number): "success" | "critical" => {
    if (score >= 80) return "success";
    return "critical";
  };

  // Format issue type for display
const formatIssueType = (type: string) => {
  return type
    .split("_")
    .map((word) => word.charAt(0) + word.slice(1).toLowerCase())
    .join(" ");
};

const FIXABLE_ISSUE_TYPES = new Set([
  "MISSING_META_TITLE",
  "DUPLICATE_META_TITLE",
  "MISSING_META_DESCRIPTION",
  "MISSING_ALT_TEXT",
]);

  // ====================
  // RENDER
  // ====================

  return (
    <Page
      title="SEO Audit"
      fullWidth
      primaryAction={
        canRunAudit
          ? {
              content: "Run New Audit",
              onAction: handleStartAudit,
              loading: isRunningAudit,
            }
          : undefined
      }
    >
      <BlockStack gap="500">
        {/* Restriction Banner */}
        {!canRunAudit && auditRestriction && (
          <Banner tone="warning">
            <p>{auditRestriction}</p>
            {nextAllowedTime && (
              <p>
                Next audit available at:{" "}
                {new Date(nextAllowedTime).toLocaleString()}
              </p>
            )}
          </Banner>
        )}

        {/* Queued / Running Audit Status */}
        {jobStatus?.status === "waiting" && (
          <Banner tone="info">
            <p>Audit queued. It will begin automatically in a moment.</p>
          </Banner>
        )}

        {audit?.status === "RUNNING" && (
          <Banner tone="info">
            <p>
              Audit in progress{jobStage ? ` â€” ${jobStage.toLowerCase()}` : ""}. This may take a few minutes.
            </p>
            <Box paddingBlockStart="200">
              <ProgressBar progress={jobProgress ?? 25} />
            </Box>
          </Banner>
        )}

        {/* No Audit State */}
        {!audit && (
          <Card>
            <EmptyState
              heading="No audits yet"
              action={{
                content: "Run Your First Audit",
                onAction: handleStartAudit,
                disabled: !canRunAudit,
              }}
              image="https://cdn.shopify.com/s/files/1/0262/4071/2726/files/emptystate-files.png"
            >
              <p>
                Start your first SEO audit to identify issues and improve your
                store's search visibility.
              </p>
            </EmptyState>
          </Card>
        )}

        {/* Statistics Cards */}
        {audit && audit.status === "COMPLETED" && (
          <Layout>
            <Layout.Section>
              <BlockStack gap="400">
                {/* Score Card */}
                <Card>
                  <BlockStack gap="400">
                    <InlineStack align="space-between" blockAlign="center">
                      <Text as="h2" variant="headingMd">
                        Overall SEO Score
                      </Text>
                      <Text as="p" variant="heading2xl" tone={getScoreColor(statistics.overallScore)}>
                        {statistics.overallScore}/100
                      </Text>
                    </InlineStack>
                    <ProgressBar
                      progress={statistics.overallScore}
                      tone={getScoreColor(statistics.overallScore)}
                    />
                    <Text as="p" variant="bodySm" tone="subdued">
                      Last audit: {new Date(audit.createdAt).toLocaleString()}
                    </Text>
                  </BlockStack>
                </Card>

                {/* Issue Statistics */}
                <Layout>
                  <Layout.Section variant="oneThird">
                    <Card>
                      <BlockStack gap="200">
                        <Text as="p" variant="bodyMd" tone="subdued">
                          Total Issues
                        </Text>
                        <Text as="p" variant="headingXl">
                          {statistics.totalIssues}
                        </Text>
                      </BlockStack>
                    </Card>
                  </Layout.Section>

                  <Layout.Section variant="oneThird">
                    <Card>
                      <BlockStack gap="200">
                        <Text as="p" variant="bodyMd">
                          Critical
                        </Text>
                        <Text as="p" variant="headingXl">
                          {statistics.criticalIssues}
                        </Text>
                      </BlockStack>
                    </Card>
                  </Layout.Section>

                  <Layout.Section variant="oneThird">
                    <Card>
                      <BlockStack gap="200">
                        <Text as="p" variant="bodyMd">
                          High
                        </Text>
                        <Text as="p" variant="headingXl">
                          {statistics.highIssues}
                        </Text>
                      </BlockStack>
                    </Card>
                  </Layout.Section>

                  <Layout.Section variant="oneThird">
                    <Card>
                      <BlockStack gap="200">
                        <Text as="p" variant="bodyMd">
                          Medium
                        </Text>
                        <Text as="p" variant="headingXl">
                          {statistics.mediumIssues}
                        </Text>
                      </BlockStack>
                    </Card>
                  </Layout.Section>

                  <Layout.Section variant="oneThird">
                    <Card>
                      <BlockStack gap="200">
                        <Text as="p" variant="bodyMd">
                          Low
                        </Text>
                        <Text as="p" variant="headingXl">
                          {statistics.lowIssues}
                        </Text>
                      </BlockStack>
                    </Card>
                  </Layout.Section>
                </Layout>

                {/* Filters */}
                <Card>
                  <BlockStack gap="300">
                    <InlineStack align="space-between" blockAlign="center">
                      <Text as="h2" variant="headingMd">
                        Filter Issues
                      </Text>
                      <Button variant="plain" onClick={() => navigate("?")}>
                        Reset Filters
                      </Button>
                    </InlineStack>

                    <BlockStack gap="200">
                      <Text as="p" variant="bodySm" tone="subdued">
                        Severity
                      </Text>
                      <ButtonGroup variant="segmented">
                        {[
                          { label: "All", value: "all" },
                          { label: "Critical", value: "critical" },
                          { label: "High", value: "high" },
                          { label: "Medium", value: "medium" },
                          { label: "Low", value: "low" },
                        ].map((option) => (
                          <Button
                            size="slim"
                            key={option.value}
                            pressed={filters.severity === option.value}
                            onClick={() => handleSeverityChange(option.value)}
                          >
                            {option.label}
                          </Button>
                        ))}
                      </ButtonGroup>
                    </BlockStack>

                    <InlineStack gap="400" align="space-between">
                      <div style={{ width: "240px" }}>
                        <Select
                          label="Issue Type"
                          options={[
                            { label: "All Types", value: "all" },
                            { label: "Missing Meta Title", value: "missing_meta_title" },
                            { label: "Duplicate Meta Title", value: "duplicate_meta_title" },
                            { label: "Missing Meta Description", value: "missing_meta_description" },
                            { label: "Missing ALT Text", value: "missing_alt_text" },
                            { label: "Broken Links", value: "broken_link" },
                            { label: "Mixed Content", value: "mixed_content" },
                            { label: "Indexing Issues", value: "noindex_page" },
                          ]}
                          value={filters.type}
                          onChange={handleTypeChange}
                        />
                      </div>
                      <div style={{ flexGrow: 1 }}>
                        <TextField
                          label="Search"
                          value={filters.search}
                          onChange={handleSearchChange}
                          placeholder="Search issues..."
                          autoComplete="off"
                          prefix={<Icon source={SearchIcon} />}
                        />
                      </div>
                    </InlineStack>
                  </BlockStack>
                </Card>

                {/* Issues Table */}
                <Card padding="0">
                  <IndexTable
                    resourceName={{ singular: "issue", plural: "issues" }}
                    itemCount={issues.length}
                    headings={[
                      { title: "Severity" },
                      { title: "Issue Type" },
                      { title: "Page" },
                      { title: "Message" },
                      { title: "Actions" },
                    ]}
                    selectable={false}
                  >
                    {issues.map((issue: any, index: number) => (
                      <IndexTable.Row id={issue.id} key={issue.id} position={index}>
                        <IndexTable.Cell>
                          {getSeverityBadge(issue.severity)}
                        </IndexTable.Cell>
                        <IndexTable.Cell>
                          <Text as="span" variant="bodyMd">
                            {formatIssueType(issue.type)}
                          </Text>
                        </IndexTable.Cell>
                        <IndexTable.Cell>
                          <Text as="span" variant="bodyMd" fontWeight="semibold">
                            {issue.page.title}
                          </Text>
                          <br />
                          <Text as="span" variant="bodySm" tone="subdued">
                            {issue.page.pageType}
                          </Text>
                        </IndexTable.Cell>
                        <IndexTable.Cell>
                          <BlockStack gap="100">
                            <Text as="span" variant="bodyMd">
                              {issue.message}
                            </Text>
                            {issue.suggestion && (
                              <Text as="span" variant="bodySm" tone="subdued">
                                {issue.suggestion}
                              </Text>
                            )}
                          </BlockStack>
                        </IndexTable.Cell>
                        <IndexTable.Cell>
                          <InlineStack gap="200">
                            {issue.url && (
                              <Button
                                size="slim"
                                url={issue.url}
                                target="_blank"
                                external
                              >
                                View Page
                              </Button>
                            )}
                            {FIXABLE_ISSUE_TYPES.has(issue.type) && (
                              <Button
                                size="slim"
                                onClick={() => handleFixIssue(issue)}
                              >
                                Fix Now
                              </Button>
                            )}
                          </InlineStack>
                        </IndexTable.Cell>
                      </IndexTable.Row>
                    ))}
                  </IndexTable>

                  {issues.length === 0 && (
                    <Box padding="600">
                      <EmptyState
                        heading="No issues found"
                        image="https://cdn.shopify.com/s/files/1/0262/4071/2726/files/emptystate-files.png"
                      >
                        <p>
                          {filters.severity !== "all" || filters.type !== "all" || filters.search
                            ? "Try adjusting your filters to see more results."
                            : "Your store has no SEO issues! Great work!"}
                        </p>
                      </EmptyState>
                    </Box>
                  )}
                </Card>
              </BlockStack>
            </Layout.Section>
          </Layout>
        )}
      </BlockStack>
    </Page>
  );
}
